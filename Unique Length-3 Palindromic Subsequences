class Solution {
public:
    // bool isPalindrome(string s) {
    //     int low = 0, high = s.size() - 1;

    //     while(low < high) {
    //         if(s[low] != s[high]) {
    //             return false;
    //         }
    //         low++;
    //         high--;
    //     }
    //     return true;
    // }
    // void generate(int ind, string s, string& ds, set<string>& st) {
    //     if(ind == s.size()) {
    //         if(ds.size() == 3) {
    //             if(isPalindrome(ds)) {
    //                 st.insert(ds);
    //             }
    //         }
    //         return;
    //     }

    //     ds += s[ind];
    //     generate(ind + 1, s, ds, st);

    //     ds.pop_back();
    //     generate(ind + 1, s, ds, st);
    // }
    // int countPalindromicSubsequence(string s) {
    //     int n = s.size();
    //     set<string> st;
    //     string ds = "";
    //     generate(0, s, ds, st);

    //     return st.size();
    // }


    int countPalindromicSubsequence(string s) {
        int n = s.size(), result = 0;;

        unordered_set<char> st;

        for(char c : s) {
            st.insert(c);
        }

        
        for(char c : st) {
            int fo = -1, lo = -1;
            for(int i = 0; i < s.size(); i++) {
                if(s[i] == c) {
                    if(fo == -1) {
                        fo = i;
                    }
                    lo = i;
                }
            }
            unordered_set<char> st2;
            for(int i = fo + 1; i <= lo - 1; i++) {
                st2.insert(s[i]);
            }
            result += st2.size();
        }
        return result;
    }
};
